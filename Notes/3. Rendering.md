# 3. Rendering

## Basics of Game Rendering

Rendering in Graphics Theory:

- Usually has a well-defined problem to solve: rendering objects with one type of effect
- Focus on representation & math correctness, instead of how the hardware implement the algorithm
- No strict performance requirement:
  - Realtime rendering (30 FPS)
  - Interactive rendering (10 FPS)
  - Offline rendering (take hours/days to render a frame)
  - Out-of-core rendering (data too large to be saved in just one machine, have to use distributed storage across several machines)



Challenges of Game Rendering

- Huge amount of object numbers, types, and wanted effects (skin, fur, fluid, foliage...). Everything is in one container; extremely complex.
- Have to understand the hardware architecture, have to deal with the architecture of modern computer with a complex combination of CPU & GPU
- Require the framerate to be stable on various devices
  - 30 FPS (60 FPS, 120 FPS+VR)
  - 2K, 4K, 8K resolution
- Limit access to CPU bandwidth & memory (only 10~20% for rendering; game logic, network, animation, physics & AI systems are major consumers of CPU and main memory)

> The rendering system in game engine is a heavily optimized practical software framework to fulfill the critical rendering requirements of games on modern hardware (PC, console and mobiles)



### Building Blocks of Rendering

Rendering Pipeline and Data

![image-20240824231646894](images/image-20240824231646894.png)



Computation - Projection and Rasterization

![1724566914692](images/1724566914692.jpg)



Computation - Shading

A shader sample code

- Constants / Parameters
- ALU algorithms
- Texture Sampling (complex & expensive)
- Branches

![image-20240824232713501](images/image-20240824232713501.png)



Computation - Texture Sampling

Filter & Mipmapping: For one texture sampling, if use trilinear filtering, will need 8 samples and 7 interpolations

![image-20240824233055504](images/image-20240824233055504.png)



The above-mentioned massive computations can resort to GPUs (dedicated hardware to solve massive jobs).



### Hardware Architecture

SIMD & SIMT

- SIMD (Single Instruction Multiple Data)

  Describes computers with multiple processing elements that perform the same operation on multiple data points simultaneously (e.g., matrix operations)

- SIMT (Single Instruction Multiple Threads)

  An execution model used in parallel computing where single instruction, multiple data (SIMD) is combined with multithreading

![image-20240824233943988](images/image-20240824233943988.png)



GPU Architecture

See more details in [Nvidia GPU Architecture](<./Extra/Nvidia GPU Architecture.md>).

![1724591577581](images/1724591577581.jpg)



Data Flow from CPU to GPU

- CPU and Main Memory
  - Data Load / Unload
  - Data Preparation
- CPU to GPU
  - High Latency
  - Limited Bandwidth
- GPU and Video Memory
  - High Performance 
  - Parallel Rendering

Move data from CPU to GPU back and forth will cause obvious latency (between logic & rendering).

> Best practice: Always minimize data transfer between CPU & GPU when possible.

![image-20240826021908244](images/image-20240826021908244.png)



Be Aware of Cache Efficiency

- Take full advantage of hardware parallel computing
- Try to avoid [von Neumann bottleneck](https://cs.stackexchange.com/questions/105712/what-is-von-neumann-bottleneck)

> "Anything the computer tries to do is bottlenecked by the connection between the processor and memory."
>
> "Getting data from memory is slower than processing it."



GPU Bounds and Performance
Application performance is limited by:

- Memory Bounds
- ALU (Arithmetic Logic Unit) Bounds 
- TMU (Texture Mapping Unit) Bound
- BW (Bandwidth) Bound



Modern Hardware Pipeline



Other State-of-Art Architectures

![image-20240826082522372](images/image-20240826082522372.png)



### Renderable

- mesh primitive (vertex buffer (position, texture, normal...), index buffer, triangle)

> Note: Remember to define a normal for each vertex!

![image-20240826083502596](images/image-20240826083502596.png)

- material
  - Phong Model
  - PBR Model
  - Subsurface Model

![image-20240826083812899](images/image-20240826083812899.png)

- texture
  - albedo
  - normal
  - metallic
  - roughness
  - ambient occlusion (ao)
  - ...
- shader (how to draw the above data)



How to Display Different Textures on a Single Model? Use submesh! Different submeshes will have their own material (texture & shader)

![image-20240826084556760](images/image-20240826084556760.png)



However, creating such data for each game object will be too consuming. To avoid memory waste, we can build a  **Resource Pool**. Each pool stores the data that could be used and shared among game objects.

![image-20240826084956510](images/image-20240826084956510.png)

![image-20240826085230702](images/image-20240826085230702.png)



Optimization 1: Render objects that share the same material together.

![image-20240826085541469](images/image-20240826085541469.png)



Optimization 2: Use GPU batch and render objects that share the same material & submesh together.

![image-20240826085848234](images/image-20240826085848234.png)



### Visibility Culling

Culling of one object: Check if its bounding box is inside the view frustum

![image-20240826090444310](images/image-20240826090444310.png)

Using the Simplest Bound to Create Culling

- Inexpensive intersection tests
- Tight fitting
- Inexpensive to compute
- Easy to rotate and transform
- Use little memory

![image-20240828083537626](images/image-20240828083537626.png)



Hierarchical View Frustum Culling

![image-20240828083744350](images/image-20240828083744350.png)



BVH: Useful when there're a large number of dynamic objects (insert new nodes fast)

![image-20240828084220302](images/image-20240828084220302.png)



PVS (Potential Visibility Set)

![image-20240828084433828](images/image-20240828084433828.png)

Portal and PVS Data: Determine potentially visible leaf nodes immediately from portal

![image-20240828193139558](images/image-20240828193139558.png)

![image-20240828193404039](images/image-20240828193404039.png)

> Though PVS has gradually faded out in visibility problems, its idea is still useful in game development.



GPU Culling

Occlusion query, Early-Z/Pre-Z:

![image-20240828193946170](images/image-20240828193946170.png)

![image-20240828194007665](images/image-20240828194007665.png)



### Texture Compression

Traditional image compression like JPG and PNG

- Good compression rates

- Image quality
- Designed to compress or decompress an entire image

E.g. Block Compression

Common block-based compression format (use interpolation of source color blocks, lossy compression)

- On PC,  BC7 (modern) or DXTC (old) formats
- On mobile, ASTC (modern) or ETC / PVRTC (old) formats

![image-20240828194933319](images/image-20240828194933319.png)



Game texture compression

- Decoding speed

- Random access (traditional block-based compression algorithms do not support random access)
- Compression rate and visual quality
- Encoding speed



### Authoring Tools of Modeling

Modeling

- Polymodeling: 3ds Max, Maya, Blender...
- Sculpting: ZBrush...
- Scanning
- Procedural Modeling: Houdini, Unreal Engine...

![image-20240828195857975](images/image-20240828195857975.png)



### Cluster-Based Mesh Pipeline

> The trend of rendering pipeline in modern game engine.

Challenge: Sculpting Tools Create Infinite Details

- Artists create models with infinite details 
- From linear fps to open world fps, complex scenes submit 10 times more triangles to GPU per-frame

Solution: Cluster-Based Mesh Pipeline

1. GPU-Driven Rendering Pipeline (2015)

   Mesh Cluster Rendering

   - Arbitrary number of meshes in single drawcall
   - GPU-culled by cluster bounds

   - Cluster depth sorting

2. Geometry Rendering Pipeline Architecture (2021)
  Rendering primitives are divided as:

  - Cluster: 64 triangles strip

  - Surf: submeshes based on materials, composed of many Clusters
  - Batch: a single API draw (``drawIndirect` / `drawIndexIndirect`), composed of many Surfs

![image-20240828210507326](images/image-20240828210507326.png)



Nanite

- Hierarchical LOD clusters with seamless boundary
- Donâ€™t need hardware support, but using a hierarchical cluster culling on the precomputed BVH tree by persistent threads (CS) on GPU instead of task shader



### Course Takeaway

1. The design of game engine is deeply related to the hardware architecture design
2. A submesh design is used to support a model with multiple materials
3. Use culling algorithms to draw as few objects as possible
4. As GPU become more powerful, more and more work are moved into GPU, which is called GPU Driven



## Lighting, Materials and Shaders

### PBR (SG, MR)



### Shader Permutation



### Lighting

Point / Directional lighting





IBL / Simple GI





## Special Rendering

### Terrain



### Sky/Fog



### Postprocessing





## Rendering Pipeline

Forward, deferred rendering, forward plus
Real pipeline with mixed effects 
Ring buffer and V-Sync
Tiled-based rendering